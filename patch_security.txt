diff -Naur security/capability.c security/capability.c
--- security/capability.c	2014-08-03 19:25:02.000000000 -0300
+++ security/capability.c	2014-08-31 12:21:06.906941744 -0300
@@ -12,6 +12,26 @@
 
 #include <linux/security.h>
 
+static int cap_binder_set_context_mgr(struct task_struct *mgr)
+{
+      return 0;
+}
+
+static int cap_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+      return 0;
+}
+
+static int cap_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+      return 0;
+}
+
+static int cap_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+      return 0;
+}
+
 static int cap_syslog(int type)
 {
 	return 0;
@@ -757,8 +777,7 @@
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 static int cap_xfrm_policy_alloc_security(struct xfrm_sec_ctx **ctxp,
-					  struct xfrm_user_sec_ctx *sec_ctx,
-					  gfp_t gfp)
+					  struct xfrm_user_sec_ctx *sec_ctx)
 {
 	return 0;
 }
@@ -925,6 +944,10 @@
 
 void __init security_fixup_ops(struct security_operations *ops)
 {
+	set_to_cap_if_null(ops, binder_set_context_mgr);
+	set_to_cap_if_null(ops, binder_transaction);
+	set_to_cap_if_null(ops, binder_transfer_binder);
+	set_to_cap_if_null(ops, binder_transfer_file);
 	set_to_cap_if_null(ops, ptrace_access_check);
 	set_to_cap_if_null(ops, ptrace_traceme);
 	set_to_cap_if_null(ops, capget);
diff -Naur security/commoncap.c security/commoncap.c
--- security/commoncap.c	2014-08-03 19:25:02.000000000 -0300
+++ security/commoncap.c	2014-08-31 12:21:07.082941723 -0300
@@ -31,6 +31,10 @@
 #include <linux/binfmts.h>
 #include <linux/personality.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -78,6 +82,13 @@
 {
 	struct user_namespace *ns = targ_ns;
 
+	#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
+		return 0;
+	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
+		return 0;	
+	#endif
+	
 	/* See if cred has the capability in the target user namespace
 	 * by examining the target user namespace and all of the target
 	 * user namespace's parents.
diff -Naur security/security.c security/security.c
--- security/security.c	2014-08-03 19:25:02.000000000 -0300
+++ security/security.c	2014-08-31 12:21:06.670941773 -0300
@@ -135,6 +135,26 @@
 
 /* Security operations */
 
+int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+      return security_ops->binder_set_context_mgr(mgr);
+}
+
+int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+      return security_ops->binder_transaction(from, to);
+}
+
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+      return security_ops->binder_transfer_binder(from, to);
+}
+
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+      return security_ops->binder_transfer_file(from, to, file);
+}
+
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
 #ifdef CONFIG_SECURITY_YAMA_STACKED
@@ -1335,11 +1355,9 @@
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 
-int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
-			       struct xfrm_user_sec_ctx *sec_ctx,
-			       gfp_t gfp)
+int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx)
 {
-	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx, gfp);
+	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx);
 }
 EXPORT_SYMBOL(security_xfrm_policy_alloc);
 
diff -Naur security/selinux/hooks.c security/selinux/hooks.c
--- security/selinux/hooks.c	2014-08-03 19:25:02.000000000 -0300
+++ security/selinux/hooks.c	2014-08-31 12:21:07.006941732 -0300
@@ -667,8 +667,7 @@
 
 		if (flags[i] == SBLABEL_MNT)
 			continue;
-		rc = security_context_to_sid(mount_options[i],
-					     strlen(mount_options[i]), &sid, GFP_KERNEL);
+		rc = security_context_to_sid(mount_options[i], len, &sid);
 		if (rc) {
 			printk(KERN_WARNING "SELinux: security_context_to_sid"
 			       "(%s) failed for (dev %s, type %s) errno=%d\n",
@@ -1924,6 +1923,67 @@
 
 /* Hook functions begin here. */
 
+static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+{
+      u32 mysid = current_sid();
+      u32 mgrsid = task_sid(mgr);
+
+      return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER, BINDER__SET_CONTEXT_MGR, NULL);
+}
+
+static int selinux_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+      u32 mysid = current_sid();
+      u32 fromsid = task_sid(from);
+      u32 tosid = task_sid(to);
+      int rc;
+
+      if (mysid != fromsid) {
+              rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER, BINDER__IMPERSONATE, NULL);
+              if (rc)
+                      return rc;
+      }
+
+      return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL, NULL);
+}
+
+static int selinux_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+      u32 fromsid = task_sid(from);
+      u32 tosid = task_sid(to);
+      return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER, NULL);
+}
+
+static int selinux_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+      u32 sid = task_sid(to);
+      struct file_security_struct *fsec = file->f_security;
+      struct inode *inode = file->f_path.dentry->d_inode;
+      struct inode_security_struct *isec = inode->i_security;
+      struct common_audit_data ad;
+      struct selinux_audit_data sad = {0,};
+      int rc;
+
+      ad.type = LSM_AUDIT_DATA_PATH;
+      ad.u.path = file->f_path;
+      ad.selinux_audit_data = &sad;
+
+      if (sid != fsec->sid) {
+              rc = avc_has_perm(sid, fsec->sid,
+                                SECCLASS_FD,
+                                FD__USE,
+                                &ad);
+              if (rc)
+                      return rc;
+      }
+
+      if (unlikely(IS_PRIVATE(inode)))
+              return 0;
+
+      return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+                          &ad);
+}
+
 static int selinux_ptrace_access_check(struct task_struct *child,
 				     unsigned int mode)
 {
@@ -2915,7 +2975,7 @@
 	if (rc)
 		return rc;
 
-	rc = security_context_to_sid(value, size, &newsid, GFP_KERNEL);
+	rc = security_context_to_sid(value, size, &newsid);
 	if (rc == -EINVAL) {
 		if (!capable(CAP_MAC_ADMIN)) {
 			struct audit_buffer *ab;
@@ -3072,7 +3132,7 @@
 	if (!value || !size)
 		return -EACCES;
 
-	rc = security_context_to_sid((void *)value, size, &newsid, GFP_KERNEL);
+	rc = security_context_to_sid((void *)value, size, &newsid);
 	if (rc)
 		return rc;
 
@@ -5550,7 +5610,7 @@
 			str[size-1] = 0;
 			size--;
 		}
-		error = security_context_to_sid(value, size, &sid, GFP_KERNEL);
+		error = security_context_to_sid(value, size, &sid);
 		if (error == -EINVAL && !strcmp(name, "fscreate")) {
 			if (!capable(CAP_MAC_ADMIN)) {
 				struct audit_buffer *ab;
@@ -5659,7 +5719,7 @@
 
 static int selinux_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
-	return security_context_to_sid(secdata, seclen, secid, GFP_KERNEL);
+	return security_context_to_sid(secdata, seclen, secid);
 }
 
 static void selinux_release_secctx(char *secdata, u32 seclen)
@@ -5764,6 +5824,14 @@
 static struct security_operations selinux_ops = {
 	.name =				"selinux",
 
+	 /**
+	  * pstglia - Android-x86 change
+	  */
+	.binder_set_context_mgr =       selinux_binder_set_context_mgr,
+	.binder_transaction =           selinux_binder_transaction,
+	.binder_transfer_binder =       selinux_binder_transfer_binder,
+	.binder_transfer_file =         selinux_binder_transfer_file,
+
 	.ptrace_access_check =		selinux_ptrace_access_check,
 	.ptrace_traceme =		selinux_ptrace_traceme,
 	.capget =			selinux_capget,
diff -Naur security/selinux/include/classmap.h security/selinux/include/classmap.h
--- security/selinux/include/classmap.h	2014-08-03 19:25:02.000000000 -0300
+++ security/selinux/include/classmap.h	2014-08-31 12:21:07.035941728 -0300
@@ -151,5 +151,6 @@
 	{ "kernel_service", { "use_as_override", "create_files_as", NULL } },
 	{ "tun_socket",
 	  { COMMON_SOCK_PERMS, "attach_queue", NULL } },
+	{ "binder", { "impersonate", "call", "set_context_mgr", "transfer", NULL } },
 	{ NULL }
   };
