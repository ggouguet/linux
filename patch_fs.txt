diff -Naur fs/eventpoll.c fs/eventpoll.c
--- fs/eventpoll.c	2014-08-03 19:25:02.000000000 -0300
+++ fs/eventpoll.c	2014-08-31 12:21:42.151937448 -0300
@@ -34,6 +34,9 @@
 #include <linux/mutex.h>
 #include <linux/anon_inodes.h>
 #include <linux/device.h>
+
+#include <linux/freezer.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/mman.h>
@@ -1637,7 +1640,8 @@
 			}
 
 			spin_unlock_irqrestore(&ep->lock, flags);
-			if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))
+			if (!freezable_schedule_hrtimeout_range(to, slack,
+                                        HRTIMER_MODE_ABS))
 				timed_out = 1;
 
 			spin_lock_irqsave(&ep->lock, flags);
diff -Naur fs/fs-writeback.c fs/fs-writeback.c
--- fs/fs-writeback.c	2014-08-03 19:25:02.000000000 -0300
+++ fs/fs-writeback.c	2014-08-31 12:21:41.636937511 -0300
@@ -1156,7 +1156,7 @@
 	if ((inode->i_state & flags) == flags)
 		return;
 
-	if (unlikely(block_dump))
+	if (unlikely(block_dump > 1))
 		block_dump___mark_inode_dirty(inode);
 
 	spin_lock(&inode->i_lock);
diff -Naur fs/fuse/dev.c fs/fuse/dev.c
--- fs/fuse/dev.c	2014-08-03 19:25:02.000000000 -0300
+++ fs/fuse/dev.c	2014-08-31 12:21:41.918937476 -0300
@@ -20,6 +20,7 @@
 #include <linux/swap.h>
 #include <linux/splice.h>
 #include <linux/aio.h>
+#include <linux/freezer.h>
 
 MODULE_ALIAS_MISCDEV(FUSE_MINOR);
 MODULE_ALIAS("devname:fuse");
@@ -464,7 +465,9 @@
 	 * Wait it out.
 	 */
 	spin_unlock(&fc->lock);
-	wait_event(req->waitq, req->state == FUSE_REQ_FINISHED);
+	while (req->state != FUSE_REQ_FINISHED)
+		wait_event_freezable(req->waitq,
+                             req->state == FUSE_REQ_FINISHED);
 	spin_lock(&fc->lock);
 
 	if (!req->aborted)
diff -Naur fs/proc/base.c fs/proc/base.c
--- fs/proc/base.c	2014-08-03 19:25:02.000000000 -0300
+++ fs/proc/base.c	2014-08-31 12:21:41.656937508 -0300
@@ -139,6 +139,13 @@
 		NULL, &proc_single_file_operations,	\
 		{ .proc_show = show } )
 
+/* ANDROID is for special files in /proc. */
+#define ANDROID(NAME, MODE, OTYPE)                    \
+      NOD(NAME, (S_IFREG|(MODE)),                     \
+              &proc_##OTYPE##_inode_operations,       \
+              &proc_##OTYPE##_operations, {})
+		
+		
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -968,6 +975,37 @@
 	return err < 0 ? err : count;
 }
 
+static int oom_adjust_permission(struct inode *inode, int mask)
+{
+      kuid_t uid;
+      struct task_struct *p;
+      kuid_t system_server_uid = KUIDT_INIT(1000);
+
+      p = get_proc_task(inode);
+      if(p) {
+              uid = task_uid(p);
+              put_task_struct(p);
+      }
+
+      /*
+       * System Server (uid == 1000) is granted access to oom_adj of all 
+       * android applications (uid > 10000) as and services (uid >= 1000)
+       */
+      if (p && (uid_eq(current_fsuid(), system_server_uid) &&
+                              uid_gt(uid, system_server_uid))) {
+              if (inode->i_mode >> 6 & mask) {
+                      return 0;
+              }
+      }
+
+      /* Fall back to default. */
+      return generic_permission(inode, mask);
+}
+
+static const struct inode_operations proc_oom_adj_inode_operations = {
+      .permission     = oom_adjust_permission,
+};
+
 static const struct file_operations proc_oom_adj_operations = {
 	.read		= oom_adj_read,
 	.write		= oom_adj_write,
@@ -2612,7 +2650,7 @@
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),
+	ANDROID("oom_adj", S_IRUGO|S_IWUSR, oom_adj),
 	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
diff -Naur fs/proc/task_mmu.c fs/proc/task_mmu.c
--- fs/proc/task_mmu.c	2014-08-03 19:25:02.000000000 -0300
+++ fs/proc/task_mmu.c	2014-08-31 12:21:41.676937506 -0300
@@ -129,6 +129,56 @@
 }
 #endif
 
+static void seq_print_vma_name(struct seq_file *m, struct vm_area_struct *vma)
+{
+      const char __user *name = vma_get_anon_name(vma);
+      struct mm_struct *mm = vma->vm_mm;
+
+      unsigned long page_start_vaddr;
+      unsigned long page_offset;
+      unsigned long num_pages;
+      unsigned long max_len = NAME_MAX;
+      int i;
+
+      page_start_vaddr = (unsigned long)name & PAGE_MASK;
+      page_offset = (unsigned long)name - page_start_vaddr;
+      num_pages = DIV_ROUND_UP(page_offset + max_len, PAGE_SIZE);
+
+      seq_puts(m, "[anon:");
+
+      for (i = 0; i < num_pages; i++) {
+              int len;
+              int write_len;
+              const char *kaddr;
+              long pages_pinned;
+              struct page *page;
+
+              pages_pinned = get_user_pages(current, mm, page_start_vaddr,
+                              1, 0, 0, &page, NULL);
+              if (pages_pinned < 1) {
+                      seq_puts(m, "<fault>]");
+                      return;
+              }
+
+              kaddr = (const char *)kmap(page);
+              len = min(max_len, PAGE_SIZE - page_offset);
+              write_len = strnlen(kaddr + page_offset, len);
+              seq_write(m, kaddr + page_offset, write_len);
+              kunmap(page);
+              put_page(page);
+
+              /* if strnlen hit a null terminator then we're done */
+              if (write_len != len)
+                      break;
+
+              max_len -= len;
+              page_offset = 0;
+              page_start_vaddr += PAGE_SIZE;
+      }
+
+      seq_putc(m, ']');
+}
+
 static void vma_stop(struct proc_maps_private *priv, struct vm_area_struct *vma)
 {
 	if (vma && vma != priv->tail_vma) {
@@ -336,6 +386,12 @@
 				seq_pad(m, ' ');
 				seq_printf(m, "[stack:%d]", tid);
 			}
+			goto done;
+		}
+
+		if (vma_get_anon_name(vma)) {
+			seq_pad(m, ' ');
+			seq_print_vma_name(m, vma);
 		}
 	}
 
@@ -637,6 +693,12 @@
 				mss.nonlinear >> 10);
 
 	show_smap_vma_flags(m, vma);
+	
+	if (vma_get_anon_name(vma)) {
+		seq_puts(m, "Name:           ");
+		seq_print_vma_name(m, vma);
+		seq_putc(m, '\n');
+	}
 
 	if (m->count < m->size)  /* vma is copied successfully */
 		m->version = (vma != get_gate_vma(task->mm))
